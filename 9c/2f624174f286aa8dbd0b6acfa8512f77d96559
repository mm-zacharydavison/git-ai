tests/github/github_test_harness.rs
  cb93822 274-275
---
{
  "schema_version": "authorship/3.0.0",
  "base_commit_sha": "91ab853e199e6026e03b93c32948c84a1e793c7e",
  "prompts": {
    "cb93822": {
      "agent_id": {
        "tool": "claude",
        "id": "cc1e5a30-2c5a-46c1-bf9d-68c94b41bad7",
        "model": "claude-sonnet-4-5-20250929"
      },
      "human_author": "Zachary Davison <zachary.davison@meetsmore.com>",
      "messages": [
        {
          "type": "user",
          "text": "wait_for_workflows looks like it doesn't actually use the pr number, we want to wait for workflows for that specific PR only:\n\ntests/github/github_test_harness.rs",
          "timestamp": "2025-10-29T12:27:51.000Z"
        },
        {
          "type": "assistant",
          "text": "I'll examine the `wait_for_workflows` function to see how it's currently implemented and fix it to properly filter by PR number.",
          "timestamp": "2025-10-29T12:27:55.389Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/home/z/Desktop/work/github/git-ai/tests/github/github_test_harness.rs"
          },
          "timestamp": "2025-10-29T12:27:55.957Z"
        },
        {
          "type": "user",
          "text": "     1→use std::process::Command;\n     2→use std::sync::OnceLock;\n     3→use crate::repos::test_repo::TestRepo;\n     4→\n     5→/// Merge strategy for pull requests\n     6→#[derive(Debug, Clone, Copy)]\n     7→pub enum MergeStrategy {\n     8→    /// Squash all commits into one\n     9→    Squash,\n    10→    /// Create a merge commit\n    11→    Merge,\n    12→    /// Rebase and merge\n    13→    Rebase,\n    14→}\n    15→\n    16→static GH_CLI_AVAILABLE: OnceLock<bool> = OnceLock::new();\n    17→\n    18→/// Check if GitHub CLI is available and authenticated\n    19→pub fn is_gh_cli_available() -> bool {\n    20→    *GH_CLI_AVAILABLE.get_or_init(|| {\n    21→        let version_check = Command::new(\"gh\")\n    22→            .arg(\"--version\")\n    23→            .output();\n    24→\n    25→        if version_check.is_err() || !version_check.unwrap().status.success() {\n    26→            return false;\n    27→        }\n    28→\n    29→        let auth_check = Command::new(\"gh\")\n    30→            .args(&[\"auth\", \"status\"])\n    31→            .output();\n    32→\n    33→        auth_check.is_ok() && auth_check.unwrap().status.success()\n    34→    })\n    35→}\n    36→\n    37→/// GitHub test repository wrapper that extends TestRepo with GitHub operations\n    38→pub struct GitHubTestRepo {\n    39→    pub repo: TestRepo,\n    40→    pub github_repo_name: String,\n    41→    pub github_owner: String,\n    42→}\n    43→\n    44→impl GitHubTestRepo {\n    45→    /// Create a new GitHub test repository with a name derived from the test\n    46→    /// Returns None if gh CLI is not available\n    47→    pub fn new(test_name: &str) -> Option<Self> {\n    48→        if !is_gh_cli_available() {\n    49→            println!(\"⏭️  Skipping GitHub test - gh CLI not available or not authenticated\");\n    50→            return None;\n    51→        }\n    52→\n    53→        let repo = TestRepo::new();\n    54→        let repo_name = generate_repo_name(test_name);\n    55→\n    56→        let owner = match get_authenticated_user() {\n    57→            Some(user) => user,\n    58→            None => {\n    59→                println!(\"⏭️  Skipping GitHub test - could not get authenticated user\");\n    60→                return None;\n    61→            }\n    62→        };\n    63→\n    64→        Some(Self {\n    65→            repo,\n    66→            github_repo_name: repo_name,\n    67→            github_owner: owner,\n    68→        })\n    69→    }\n    70→\n    71→    /// Initialize the repository and create it on GitHub\n    72→    pub fn create_on_github(&self) -> Result<(), String> {\n    73→        let repo_path = self.repo.path();\n    74→\n    75→        // Create initial commit (required for gh repo create)\n    76→        std::fs::write(repo_path.join(\"README.md\"), \"# GitHub Test Repository\\n\")\n    77→            .map_err(|e| format!(\"Failed to create README: {}\", e))?;\n    78→\n    79→        self.repo.git(&[\"add\", \".\"])\n    80→            .map_err(|e| format!(\"Failed to add files: {}\", e))?;\n    81→\n    82→        self.repo.git(&[\"commit\", \"-m\", \"Initial commit\"])\n    83→            .map_err(|e| format!(\"Failed to create initial commit: {}\", e))?;\n    84→\n    85→        // Create GitHub repository\n    86→        let output = Command::new(\"gh\")\n    87→            .args(&[\n    88→                \"repo\", \"create\",\n    89→                &self.github_repo_name,\n    90→                \"--public\",\n    91→                \"--source\", repo_path.to_str().unwrap(),\n    92→                \"--push\"\n    93→            ])\n    94→            .current_dir(repo_path)\n    95→            .output()\n    96→            .map_err(|e| format!(\"Failed to execute gh repo create: {}\", e))?;\n    97→\n    98→        if !output.status.success() {\n    99→            return Err(format!(\n   100→                \"Failed to create GitHub repository:\\n{}\",\n   101→                String::from_utf8_lossy(&output.stderr)\n   102→            ));\n   103→        }\n   104→\n   105→        println!(\"✅ Created GitHub repository: {}/{}\", self.github_owner, self.github_repo_name);\n   106→        Ok(())\n   107→    }\n   108→\n   109→    /// Create a new branch\n   110→    pub fn create_branch(&self, branch_name: &str) -> Result<(), String> {\n   111→        self.repo.git(&[\"checkout\", \"-b\", branch_name]).map(|_| ())\n   112→    }\n   113→\n   114→    /// Push current branch to GitHub\n   115→    pub fn push_branch(&self, branch_name: &str) -> Result<(), String> {\n   116→        self.repo.git(&[\"push\", \"--set-upstream\", \"origin\", branch_name]).map(|_| ())\n   117→    }\n   118→\n   119→    /// Create a pull request\n   120→    pub fn create_pr(&self, title: &str, body: &str) -> Result<String, String> {\n   121→        let repo_path = self.repo.path();\n   122→\n   123→        let output = Command::new(\"gh\")\n   124→            .args(&[\n   125→                \"pr\", \"create\",\n   126→                \"--title\", title,\n   127→                \"--body\", body\n   128→            ])\n   129→            .current_dir(repo_path)\n   130→            .output()\n   131→            .map_err(|e| format!(\"Failed to execute gh pr create: {}\", e))?;\n   132→\n   133→        if !output.status.success() {\n   134→            return Err(format!(\n   135→                \"Failed to create PR:\\n{}\",\n   136→                String::from_utf8_lossy(&output.stderr)\n   137→            ));\n   138→        }\n   139→\n   140→        let pr_url = String::from_utf8_lossy(&output.stdout).trim().to_string();\n   141→        println!(\"✅ Created pull request: {}\", pr_url);\n   142→        Ok(pr_url)\n   143→    }\n   144→\n   145→    /// Merge a pull request with the specified strategy\n   146→    pub fn merge_pr(&self, pr_number: &str, strategy: MergeStrategy) -> Result<(), String> {\n   147→        let repo_path = self.repo.path();\n   148→\n   149→        let strategy_flag = match strategy {\n   150→            MergeStrategy::Squash => \"--squash\",\n   151→            MergeStrategy::Merge => \"--merge\",\n   152→            MergeStrategy::Rebase => \"--rebase\",\n   153→        };\n   154→\n   155→        let output = Command::new(\"gh\")\n   156→            .args(&[\n   157→                \"pr\", \"merge\",\n   158→                pr_number,\n   159→                strategy_flag,\n   160→                \"--delete-branch\"\n   161→            ])\n   162→            .current_dir(repo_path)\n   163→            .output()\n   164→            .map_err(|e| format!(\"Failed to execute gh pr merge: {}\", e))?;\n   165→\n   166→        if !output.status.success() {\n   167→            return Err(format!(\n   168→                \"Failed to merge PR:\\n{}\",\n   169→                String::from_utf8_lossy(&output.stderr)\n   170→            ));\n   171→        }\n   172→\n   173→        println!(\"✅ Merged pull request #{} using {:?} strategy\", pr_number, strategy);\n   174→        Ok(())\n   175→    }\n   176→\n   177→    /// Get the PR number from a PR URL\n   178→    pub fn extract_pr_number(&self, pr_url: &str) -> Option<String> {\n   179→        pr_url.split('/').last().map(|s| s.to_string())\n   180→    }\n   181→\n   182→    /// Get the default branch name from the remote repository\n   183→    pub fn get_default_branch(&self) -> Result<String, String> {\n   184→        let repo_path = self.repo.path();\n   185→        let full_repo = format!(\"{}/{}\", self.github_owner, self.github_repo_name);\n   186→\n   187→        let output = Command::new(\"gh\")\n   188→            .args(&[\"repo\", \"view\", &full_repo, \"--json\", \"defaultBranchRef\", \"--jq\", \".defaultBranchRef.name\"])\n   189→            .current_dir(repo_path)\n   190→            .output()\n   191→            .map_err(|e| format!(\"Failed to get default branch: {}\", e))?;\n   192→\n   193→        if !output.status.success() {\n   194→            return Err(format!(\n   195→                \"Failed to get default branch:\\n{}\",\n   196→                String::from_utf8_lossy(&output.stderr)\n   197→            ));\n   198→        }\n   199→\n   200→        Ok(String::from_utf8_lossy(&output.stdout).trim().to_string())\n   201→    }\n   202→\n   203→    /// Install the GitHub CI workflow in the repository\n   204→    pub fn install_github_ci_workflow(&self) -> Result<(), String> {\n   205→        // Use git-ai to install the workflow\n   206→        let output = self.repo.git_ai(&[\"ci\", \"github\", \"install\"])\n   207→            .map_err(|e| format!(\"Failed to install CI workflow: {}\", e))?;\n   208→\n   209→        println!(\"✅ Installed GitHub CI workflow\");\n   210→        println!(\"{}\", output);\n   211→\n   212→        // Commit and push the workflow file\n   213→        self.repo.git(&[\"add\", \".github/workflows/git-ai.yaml\"])\n   214→            .map_err(|e| format!(\"Failed to add workflow file: {}\", e))?;\n   215→\n   216→        self.repo.git(&[\"commit\", \"-m\", \"Add git-ai CI workflow\"])\n   217→            .map_err(|e| format!(\"Failed to commit workflow: {}\", e))?;\n   218→\n   219→        self.repo.git(&[\"push\"])\n   220→            .map_err(|e| format!(\"Failed to push workflow: {}\", e))?;\n   221→\n   222→        println!(\"✅ Committed and pushed CI workflow\");\n   223→        Ok(())\n   224→    }\n   225→\n   226→    /// Get the logs for a specific workflow run\n   227→    pub fn get_workflow_logs(&self, run_id: &str) -> Result<String, String> {\n   228→        let repo_path = self.repo.path();\n   229→        let full_repo = format!(\"{}/{}\", self.github_owner, self.github_repo_name);\n   230→\n   231→        let output = Command::new(\"gh\")\n   232→            .args(&[\n   233→                \"run\", \"view\",\n   234→                run_id,\n   235→                \"--repo\", &full_repo,\n   236→                \"--log\"\n   237→            ])\n   238→            .current_dir(repo_path)\n   239→            .output()\n   240→            .map_err(|e| format!(\"Failed to get workflow logs: {}\", e))?;\n   241→\n   242→        if !output.status.success() {\n   243→            return Err(format!(\n   244→                \"Failed to get workflow logs:\\n{}\",\n   245→                String::from_utf8_lossy(&output.stderr)\n   246→            ));\n   247→        }\n   248→\n   249→        Ok(String::from_utf8_lossy(&output.stdout).to_string())\n   250→    }\n   251→\n   252→    /// Wait for GitHub Actions workflow runs to complete for a specific PR\n   253→    /// Returns an error if any workflow fails\n   254→    pub fn wait_for_workflows(&self, pr_number: &str, timeout_seconds: u64) -> Result<(), String> {\n   255→        let repo_path = self.repo.path();\n   256→        let full_repo = format!(\"{}/{}\", self.github_owner, self.github_repo_name);\n   257→\n   258→        println!(\"⏳ Waiting for GitHub Actions workflows to complete (timeout: {}s)...\", timeout_seconds);\n   259→\n   260→        use std::time::{Duration, Instant};\n   261→        let start = Instant::now();\n   262→        let timeout = Duration::from_secs(timeout_seconds);\n   263→\n   264→        loop {\n   265→            if start.elapsed() > timeout {\n   266→                return Err(format!(\"Timeout waiting for workflows to complete after {}s\", timeout_seconds));\n   267→            }\n   268→\n   269→            // Get workflow runs for the PR\n   270→            let output = Command::new(\"gh\")\n   271→                .args(&[\n   272→                    \"run\", \"list\",\n   273→                    \"--repo\", &full_repo,\n   274→                    \"--json\", \"status,conclusion,name,databaseId\",\n   275→                    \"--limit\", \"10\"\n   276→                ])\n   277→                .current_dir(repo_path)\n   278→                .output()\n   279→                .map_err(|e| format!(\"Failed to list workflow runs: {}\", e))?;\n   280→\n   281→            if !output.status.success() {\n   282→                return Err(format!(\n   283→                    \"Failed to list workflow runs:\\n{}\",\n   284→                    String::from_utf8_lossy(&output.stderr)\n   285→                ));\n   286→            }\n   287→\n   288→            let runs_json = String::from_utf8_lossy(&output.stdout);\n   289→            let runs: Vec<serde_json::Value> = serde_json::from_str(&runs_json)\n   290→                .map_err(|e| format!(\"Failed to parse workflow runs JSON: {}\", e))?;\n   291→\n   292→            // Check if there are any runs\n   293→            if runs.is_empty() {\n   294→                println!(\"   No workflow runs found yet, waiting...\");\n   295→                std::thread::sleep(Duration::from_secs(5));\n   296→                continue;\n   297→            }\n   298→\n   299→            // Check status of all runs\n   300→            let mut all_completed = true;\n   301→            let mut any_failed = false;\n   302→            let mut failed_run_ids = Vec::new();\n   303→\n   304→            for run in &runs {\n   305→                let status = run[\"status\"].as_str().unwrap_or(\"unknown\");\n   306→                let name = run[\"name\"].as_str().unwrap_or(\"unknown\");\n   307→                let run_id = run[\"databaseId\"].as_u64().unwrap_or(0);\n   308→\n   309→                if status != \"completed\" {\n   310→                    all_completed = false;\n   311→                    println!(\"   Workflow '{}': {}\", name, status);\n   312→                }\n   313→\n   314→                if status == \"completed\" {\n   315→                    let conclusion = run[\"conclusion\"].as_str().unwrap_or(\"unknown\");\n   316→                    if conclusion != \"success\" {\n   317→                        any_failed = true;\n   318→                        failed_run_ids.push(run_id.to_string());\n   319→                        println!(\"   ❌ Workflow '{}' failed with conclusion: {}\", name, conclusion);\n   320→                    } else {\n   321→                        println!(\"   ✅ Workflow '{}' completed successfully\", name);\n   322→                    }\n   323→                }\n   324→            }\n   325→\n   326→            if all_completed {\n   327→                if any_failed {\n   328→                    // Fetch and display logs for failed workflows\n   329→                    for run_id in &failed_run_ids {\n   330→                        println!(\"\\n📋 Logs for failed workflow run {}:\", run_id);\n   331→                        match self.get_workflow_logs(run_id) {\n   332→                            Ok(logs) => {\n   333→                                // Print last 100 lines of logs\n   334→                                let lines: Vec<&str> = logs.lines().collect();\n   335→                                let start_line = if lines.len() > 100 { lines.len() - 100 } else { 0 };\n   336→                                for line in &lines[start_line..] {\n   337→                                    println!(\"{}\", line);\n   338→                                }\n   339→                            }\n   340→                            Err(e) => println!(\"Failed to fetch logs: {}\", e)\n   341→                        }\n   342→                    }\n   343→                    return Err(\"One or more workflows failed\".to_string());\n   344→                }\n   345→                println!(\"✅ All workflows completed successfully\");\n   346→                return Ok(());\n   347→            }\n   348→\n   349→            std::thread::sleep(Duration::from_secs(5));\n   350→        }\n   351→    }\n   352→\n   353→    /// Checkout default branch and pull latest changes from remote\n   354→    pub fn checkout_and_pull_default_branch(&self) -> Result<(), String> {\n   355→        let default_branch = self.get_default_branch()?;\n   356→        self.repo.git(&[\"checkout\", &default_branch])?;\n   357→        self.repo.git(&[\"pull\", \"origin\", &default_branch])?;\n   358→        println!(\"✅ Checked out and pulled latest {} branch\", default_branch);\n   359→        Ok(())\n   360→    }\n   361→\n   362→    /// Delete the GitHub repository\n   363→    pub fn delete_from_github(&self) -> Result<(), String> {\n   364→        let full_repo = format!(\"{}/{}\", self.github_owner, self.github_repo_name);\n   365→\n   366→        let output = Command::new(\"gh\")\n   367→            .args(&[\n   368→                \"repo\", \"delete\",\n   369→                &full_repo,\n   370→                \"--yes\"\n   371→            ])\n   372→            .output()\n   373→            .map_err(|e| format!(\"Failed to execute gh repo delete: {}\", e))?;\n   374→\n   375→        if !output.status.success() {\n   376→            return Err(format!(\n   377→                \"Failed to delete GitHub repository:\\n{}\",\n   378→                String::from_utf8_lossy(&output.stderr)\n   379→            ));\n   380→        }\n   381→\n   382→        println!(\"✅ Deleted GitHub repository: {}\", full_repo);\n   383→        Ok(())\n   384→    }\n   385→}\n   386→\n   387→impl Drop for GitHubTestRepo {\n   388→    fn drop(&mut self) {\n   389→        if std::env::var(\"GIT_AI_TEST_NO_CLEANUP\").is_ok() {\n   390→            eprintln!(\"⚠️  Cleanup disabled - repository preserved: {}/{}\",\n   391→                self.github_owner, self.github_repo_name);\n   392→            eprintln!(\"   URL: https://github.com/{}/{}\",\n   393→                self.github_owner, self.github_repo_name);\n   394→            return;\n   395→        }\n   396→\n   397→        if let Err(e) = self.delete_from_github() {\n   398→            eprintln!(\"⚠️  Failed to cleanup GitHub repository: {}\", e);\n   399→            eprintln!(\"   Manual cleanup required: {}/{}\", self.github_owner, self.github_repo_name);\n   400→        }\n   401→    }\n   402→}\n   403→\n   404→/// Generate a unique repository name for testing based on test name\n   405→fn generate_repo_name(test_name: &str) -> String {\n   406→    use std::time::{SystemTime, UNIX_EPOCH};\n   407→\n   408→    let timestamp = SystemTime::now()\n   409→        .duration_since(UNIX_EPOCH)\n   410→        .unwrap()\n   411→        .as_secs();\n   412→\n   413→    // Sanitize test name: lowercase, replace special chars with hyphens\n   414→    let sanitized_name = test_name\n   415→        .to_lowercase()\n   416→        .chars()\n   417→        .map(|c| if c.is_alphanumeric() { c } else { '-' })\n   418→        .collect::<String>()\n   419→        .trim_matches('-')\n   420→        .to_string();\n   421→\n   422→    // Truncate if too long (GitHub has a 100 char limit for repo names)\n   423→    let max_name_len = 50;\n   424→    let truncated_name = if sanitized_name.len() > max_name_len {\n   425→        &sanitized_name[..max_name_len]\n   426→    } else {\n   427→        &sanitized_name\n   428→    };\n   429→\n   430→    format!(\"git-ai-{}-{}\", truncated_name, timestamp)\n   431→}\n   432→\n   433→/// Get the authenticated GitHub user\n   434→fn get_authenticated_user() -> Option<String> {\n   435→    let output = Command::new(\"gh\")\n   436→        .args(&[\"api\", \"user\", \"--jq\", \".login\"])\n   437→        .output()\n   438→        .ok()?;\n   439→\n   440→    if !output.status.success() {\n   441→        return None;\n   442→    }\n   443→\n   444→    Some(String::from_utf8_lossy(&output.stdout).trim().to_string())\n   445→}\n   446→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-10-29T12:27:56.149Z"
        },
        {
          "type": "assistant",
          "text": "I can see the issue. The `wait_for_workflows` function accepts a `pr_number` parameter but doesn't use it when listing workflow runs on line 270-276. It's currently fetching all recent workflow runs instead of filtering to just the specific PR.\n\nI'll fix this by adding the `--pr` flag to filter workflow runs for that specific PR:",
          "timestamp": "2025-10-29T12:28:03.757Z"
        },
        {
          "type": "tool_use",
          "name": "Edit",
          "input": {
            "file_path": "/home/z/Desktop/work/github/git-ai/tests/github/github_test_harness.rs",
            "new_string": "            // Get workflow runs for the PR\n            let output = Command::new(\"gh\")\n                .args(&[\n                    \"run\", \"list\",\n                    \"--repo\", &full_repo,\n                    \"--pr\", pr_number,\n                    \"--json\", \"status,conclusion,name,databaseId\",\n                    \"--limit\", \"10\"\n                ])\n                .current_dir(repo_path)\n                .output()\n                .map_err(|e| format!(\"Failed to list workflow runs: {}\", e))?;",
            "old_string": "            // Get workflow runs for the PR\n            let output = Command::new(\"gh\")\n                .args(&[\n                    \"run\", \"list\",\n                    \"--repo\", &full_repo,\n                    \"--json\", \"status,conclusion,name,databaseId\",\n                    \"--limit\", \"10\"\n                ])\n                .current_dir(repo_path)\n                .output()\n                .map_err(|e| format!(\"Failed to list workflow runs: {}\", e))?;"
          },
          "timestamp": "2025-10-29T12:28:06.798Z"
        }
      ],
      "total_additions": 1,
      "total_deletions": 0,
      "accepted_lines": 2,
      "overriden_lines": 0
    }
  }
}
