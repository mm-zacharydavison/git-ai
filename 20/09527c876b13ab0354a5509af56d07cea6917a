src/commands/git_ai_handlers.rs
  bc49de0 64,67-68,70,72-75,77-80,85-87,117-133,136
---
{
  "schema_version": "authorship/3.0.0",
  "base_commit_sha": "6436afbf0139195fd94a25dcf71cc330399951c4",
  "prompts": {
    "bc49de0": {
      "agent_id": {
        "tool": "claude",
        "id": "96f9e44b-3e4f-4426-bcc6-cb28d35370b8",
        "model": "claude-sonnet-4-5-20250929"
      },
      "human_author": "Sasha Varlamov <sasha@sashavarlamov.com>",
      "messages": [
        {
          "type": "assistant",
          "text": "I'll add \"blame-ai\" as an alternative way to call the blame handler.",
          "timestamp": "2025-10-13T21:02:07.199Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/Users/svarlamov/projects/git-ai/src/commands/git_ai_handlers.rs"
          },
          "timestamp": "2025-10-13T21:02:07.401Z"
        },
        {
          "type": "user",
          "text": "     1→use crate::authorship::stats::stats_command;\n     2→use crate::authorship::working_log::AgentId;\n     3→use crate::commands;\n     4→use crate::commands::checkpoint_agent::agent_preset::{\n     5→    AgentCheckpointFlags, AgentCheckpointPreset, AgentRunResult, ClaudePreset, CursorPreset,\n     6→    GithubCopilotPreset,\n     7→};\n     8→use crate::config;\n     9→use crate::git::find_repository;\n    10→use crate::git::find_repository_in_path;\n    11→use std::io::IsTerminal;\n    12→use std::io::Read;\n    13→\n    14→pub fn handle_git_ai(args: &[String]) {\n    15→    if args.is_empty() {\n    16→        print_help();\n    17→        return;\n    18→    }\n    19→    match args[0].as_str() {\n    20→        \"help\" | \"--help\" | \"-h\" => {\n    21→            print_help();\n    22→        }\n    23→        \"version\" | \"--version\" | \"-v\" => {\n    24→            println!(env!(\"CARGO_PKG_VERSION\"));\n    25→            std::process::exit(0);\n    26→        }\n    27→        \"stats-delta\" => {\n    28→            handle_stats_delta(&args[1..]);\n    29→        }\n    30→        \"stats\" => {\n    31→            handle_stats(&args[1..]);\n    32→        }\n    33→        \"checkpoint\" => {\n    34→            handle_checkpoint(&args[1..]);\n    35→        }\n    36→        \"blame\" => {\n    37→            handle_ai_blame(&args[1..]);\n    38→        }\n    39→        \"git-path\" => {\n    40→            let config = config::Config::get();\n    41→            println!(\"{}\", config.git_cmd());\n    42→            std::process::exit(0);\n    43→        }\n    44→        \"install-hooks\" => {\n    45→            if let Err(e) = commands::install_hooks::run(&args[1..]) {\n    46→                eprintln!(\"Install hooks failed: {}\", e);\n    47→                std::process::exit(1);\n    48→            }\n    49→        }\n    50→\n    51→        \"squash-authorship\" => {\n    52→            commands::squash_authorship::handle_squash_authorship(&args[1..]);\n    53→        }\n    54→        _ => {\n    55→            println!(\"Unknown git-ai command: {}\", args[0]);\n    56→            std::process::exit(1);\n    57→        }\n    58→    }\n    59→}\n    60→\n    61→fn print_help() {\n    62→    eprintln!(\"git-ai - git proxy with AI authorship tracking\");\n    63→    eprintln!(\"\");\n    64→    eprintln!(\"Usage: git-ai <command> [args...]\");\n    65→    eprintln!(\"\");\n    66→    eprintln!(\"Commands:\");\n    67→    eprintln!(\"  checkpoint         Checkpoint working changes and attribute author\");\n    68→    eprintln!(\"    Presets: claude, cursor, github-copilot, mock_ai\");\n    69→    eprintln!(\"    --hook-input <json|stdin>   JSON payload required by presets, or 'stdin' to read from stdin\");\n    70→    eprintln!(\"    --show-working-log          Display current working log\");\n    71→    eprintln!(\"    --reset                     Reset working log\");\n    72→    eprintln!(\"  blame <file>       Git blame with AI authorship overlay\");\n    73→    eprintln!(\"  stats [commit]     Show AI authorship statistics for a commit\");\n    74→    eprintln!(\"    --json                 Output in JSON format\");\n    75→    eprintln!(\"  stats-delta        Generate authorship logs for children of commits with working logs\");\n    76→    eprintln!(\"    --json                 Output created notes as JSON\");\n    77→    eprintln!(\"  install-hooks      Install git hooks for AI authorship tracking\");\n    78→    eprintln!(\"  squash-authorship  Generate authorship from squashed commits\");\n    79→    eprintln!(\"    <branch> <new_sha> <old_sha>  Required: branch, new commit SHA, old commit SHA\");\n    80→    eprintln!(\"    --dry-run             Show what would be done without making changes\");\n    81→    eprintln!(\"  git-path           Print the path to the underlying git executable\");\n    82→    eprintln!(\"  version, -v, --version     Print the git-ai version\");\n    83→    eprintln!(\"  help, -h, --help           Show this help message\");\n    84→    eprintln!(\"\");\n    85→    std::process::exit(0);\n    86→}\n    87→\n    88→fn handle_checkpoint(args: &[String]) {\n    89→    let mut repository_working_dir = std::env::current_dir()\n    90→        .unwrap()\n    91→        .to_string_lossy()\n    92→        .to_string();\n    93→\n    94→    // Parse checkpoint-specific arguments\n    95→    let mut show_working_log = false;\n    96→    let mut reset = false;\n    97→    let mut hook_input = None;\n    98→\n    99→    let mut i = 0;\n   100→    while i < args.len() {\n   101→        match args[i].as_str() {\n   102→            \"--show-working-log\" => {\n   103→                show_working_log = true;\n   104→                i += 1;\n   105→            }\n   106→            \"--reset\" => {\n   107→                reset = true;\n   108→                i += 1;\n   109→            }\n   110→            \"--hook-input\" => {\n   111→                if i + 1 < args.len() {\n   112→                    hook_input = Some(args[i + 1].clone());\n   113→                    if hook_input.as_ref().unwrap() == \"stdin\" {\n   114→                        let mut stdin = std::io::stdin();\n   115→                        let mut buffer = String::new();\n   116→                        if let Err(e) = stdin.read_to_string(&mut buffer) {\n   117→                            eprintln!(\"Failed to read stdin for hook input: {}\", e);\n   118→                            std::process::exit(1);\n   119→                        }\n   120→                        if !buffer.trim().is_empty() {\n   121→                            hook_input = Some(buffer);\n   122→                        } else {\n   123→                            eprintln!(\"No hook input provided (via --hook-input or stdin).\");\n   124→                            std::process::exit(1);\n   125→                        }\n   126→                    } else if hook_input.as_ref().unwrap().trim().is_empty() {\n   127→                        eprintln!(\"Error: --hook-input requires a value\");\n   128→                        std::process::exit(1);\n   129→                    }\n   130→                    i += 2;\n   131→                } else {\n   132→                    eprintln!(\"Error: --hook-input requires a value or 'stdin' to read from stdin\");\n   133→                    std::process::exit(1);\n   134→                }\n   135→            }\n   136→\n   137→            _ => {\n   138→                i += 1;\n   139→            }\n   140→        }\n   141→    }\n   142→\n   143→    let mut agent_run_result = None;\n   144→    // Handle preset arguments after parsing all flags\n   145→    if !args.is_empty() {\n   146→        match args[0].as_str() {\n   147→            \"claude\" => {\n   148→                match ClaudePreset.run(AgentCheckpointFlags {\n   149→                    hook_input: hook_input.clone(),\n   150→                }) {\n   151→                    Ok(agent_run) => {\n   152→                        agent_run_result = Some(agent_run);\n   153→                    }\n   154→                    Err(e) => {\n   155→                        eprintln!(\"Claude preset error: {}\", e);\n   156→                        std::process::exit(1);\n   157→                    }\n   158→                }\n   159→            }\n   160→            \"cursor\" => {\n   161→                match CursorPreset.run(AgentCheckpointFlags {\n   162→                    hook_input: hook_input.clone(),\n   163→                }) {\n   164→                    Ok(agent_run) => {\n   165→                        if agent_run.is_human {\n   166→                            agent_run_result = None;\n   167→                            if agent_run.repo_working_dir.is_some() {\n   168→                                repository_working_dir = agent_run.repo_working_dir.unwrap();\n   169→                            }\n   170→                        } else {\n   171→                            agent_run_result = Some(agent_run);\n   172→                        }\n   173→                    }\n   174→                    Err(e) => {\n   175→                        eprintln!(\"Error running Cursor preset: {}\", e);\n   176→                        std::process::exit(1);\n   177→                    }\n   178→                }\n   179→            }\n   180→            \"github-copilot\" => {\n   181→                match GithubCopilotPreset.run(AgentCheckpointFlags {\n   182→                    hook_input: hook_input.clone(),\n   183→                }) {\n   184→                    Ok(agent_run) => {\n   185→                        agent_run_result = Some(agent_run);\n   186→                    }\n   187→                    Err(e) => {\n   188→                        eprintln!(\"Github Copilot preset error: {}\", e);\n   189→                        std::process::exit(1);\n   190→                    }\n   191→                }\n   192→            }\n   193→            \"mock_ai\" => {\n   194→                agent_run_result = Some(AgentRunResult {\n   195→                    agent_id: AgentId {\n   196→                        tool: \"some-ai\".to_string(),\n   197→                        id: \"ai-thread\".to_string(),\n   198→                        model: \"unknown\".to_string(),\n   199→                    },\n   200→                    is_human: false,\n   201→                    transcript: None,\n   202→                    repo_working_dir: None,\n   203→                    edited_filepaths: None,\n   204→                });\n   205→            }\n   206→            _ => {}\n   207→        }\n   208→    }\n   209→\n   210→    let final_working_dir = agent_run_result\n   211→        .as_ref()\n   212→        .and_then(|r| r.repo_working_dir.clone())\n   213→        .unwrap_or_else(|| repository_working_dir);\n   214→    // Find the git repository\n   215→    let repo = match find_repository_in_path(&final_working_dir) {\n   216→        Ok(repo) => repo,\n   217→        Err(e) => {\n   218→            eprintln!(\"Failed to find repository: {}\", e);\n   219→            std::process::exit(1);\n   220→        }\n   221→    };\n   222→\n   223→    // Get the current user name from git config\n   224→    let default_user_name = match repo.config_get_str(\"user.name\") {\n   225→        Ok(Some(name)) if !name.trim().is_empty() => name,\n   226→        _ => {\n   227→            eprintln!(\"Warning: git user.name not configured. Using 'unknown' as author.\");\n   228→            \"unknown\".to_string()\n   229→        }\n   230→    };\n   231→\n   232→    if let Err(e) = commands::checkpoint::run(\n   233→        &repo,\n   234→        &default_user_name,\n   235→        show_working_log,\n   236→        reset,\n   237→        false,\n   238→        agent_run_result,\n   239→    ) {\n   240→        eprintln!(\"Checkpoint failed: {}\", e);\n   241→        std::process::exit(1);\n   242→    }\n   243→}\n   244→\n   245→fn handle_stats_delta(args: &[String]) {\n   246→    // Parse stats-delta-specific arguments\n   247→    let mut json_output = false;\n   248→\n   249→    let mut i = 0;\n   250→    while i < args.len() {\n   251→        match args[i].as_str() {\n   252→            \"--json\" => {\n   253→                json_output = true;\n   254→                i += 1;\n   255→            }\n   256→            _ => {\n   257→                eprintln!(\"Unknown stats-delta argument: {}\", args[i]);\n   258→                std::process::exit(1);\n   259→            }\n   260→        }\n   261→    }\n   262→\n   263→    // TODO: Do we have any 'global' args for the stats-delta?\n   264→    // Find the git repository\n   265→    let repo = match find_repository(&Vec::<String>::new()) {\n   266→        Ok(repo) => repo,\n   267→        Err(e) => {\n   268→            eprintln!(\"Failed to find repository: {}\", e);\n   269→            std::process::exit(1);\n   270→        }\n   271→    };\n   272→\n   273→    if let Err(e) = commands::stats_delta::run(&repo, json_output) {\n   274→        eprintln!(\"Stats delta failed: {}\", e);\n   275→        std::process::exit(1);\n   276→    }\n   277→}\n   278→\n   279→fn handle_ai_blame(args: &[String]) {\n   280→    if args.is_empty() {\n   281→        eprintln!(\"Error: blame requires a file argument\");\n   282→        std::process::exit(1);\n   283→    }\n   284→\n   285→    // TODO: Do we have any 'global' args for the ai-blame?\n   286→    // Find the git repository\n   287→    let repo = match find_repository(&Vec::<String>::new()) {\n   288→        Ok(repo) => repo,\n   289→        Err(e) => {\n   290→            eprintln!(\"Failed to find repository: {}\", e);\n   291→            std::process::exit(1);\n   292→        }\n   293→    };\n   294→\n   295→    // Parse blame arguments\n   296→    let (file_path, options) = match commands::blame::parse_blame_args(args) {\n   297→        Ok(result) => result,\n   298→        Err(e) => {\n   299→            eprintln!(\"Failed to parse blame arguments: {}\", e);\n   300→            std::process::exit(1);\n   301→        }\n   302→    };\n   303→\n   304→    // Check if this is an interactive terminal\n   305→    let is_interactive = std::io::stdout().is_terminal();\n   306→\n   307→    if is_interactive && options.incremental {\n   308→        // For incremental mode in interactive terminal, we need special handling\n   309→        // This would typically involve a pager like less\n   310→        eprintln!(\"Error: incremental mode is not supported in interactive terminal\");\n   311→        std::process::exit(1);\n   312→    }\n   313→\n   314→    if let Err(e) = repo.blame(&file_path, &options) {\n   315→        eprintln!(\"Blame failed: {}\", e);\n   316→        std::process::exit(1);\n   317→    }\n   318→}\n   319→\n   320→fn handle_stats(args: &[String]) {\n   321→    // Parse stats-specific arguments\n   322→    let mut json_output = false;\n   323→    let mut commit_sha = None;\n   324→\n   325→    let mut i = 0;\n   326→    while i < args.len() {\n   327→        match args[i].as_str() {\n   328→            \"--json\" => {\n   329→                json_output = true;\n   330→                i += 1;\n   331→            }\n   332→            _ => {\n   333→                // First non-flag argument is treated as commit SHA\n   334→                if commit_sha.is_none() {\n   335→                    commit_sha = Some(args[i].clone());\n   336→                    i += 1;\n   337→                } else {\n   338→                    eprintln!(\"Unknown stats argument: {}\", args[i]);\n   339→                    std::process::exit(1);\n   340→                }\n   341→            }\n   342→        }\n   343→    }\n   344→\n   345→    // Find the git repository\n   346→    let repo = match find_repository(&Vec::<String>::new()) {\n   347→        Ok(repo) => repo,\n   348→        Err(e) => {\n   349→            eprintln!(\"Failed to find repository: {}\", e);\n   350→            std::process::exit(1);\n   351→        }\n   352→    };\n   353→\n   354→    if let Err(e) = stats_command(&repo, commit_sha.as_deref(), json_output) {\n   355→        match e {\n   356→            crate::error::GitAiError::Generic(msg) if msg.starts_with(\"No commit found:\") => {\n   357→                eprintln!(\"{}\", msg);\n   358→            }\n   359→            _ => {\n   360→                eprintln!(\"Stats failed: {}\", e);\n   361→            }\n   362→        }\n   363→        std::process::exit(1);\n   364→    }\n   365→}\n   366→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-10-13T21:02:07.463Z"
        },
        {
          "type": "tool_use",
          "name": "Edit",
          "input": {
            "file_path": "/Users/svarlamov/projects/git-ai/src/commands/git_ai_handlers.rs",
            "new_string": "        \"blame\" | \"blame-ai\" => {\n            handle_ai_blame(&args[1..]);\n        }",
            "old_string": "        \"blame\" => {\n            handle_ai_blame(&args[1..]);\n        }"
          },
          "timestamp": "2025-10-13T21:02:12.254Z"
        },
        {
          "type": "user",
          "text": "The file /Users/svarlamov/projects/git-ai/src/commands/git_ai_handlers.rs has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n    32→        }\n    33→        \"checkpoint\" => {\n    34→            handle_checkpoint(&args[1..]);\n    35→        }\n    36→        \"blame\" | \"blame-ai\" => {\n    37→            handle_ai_blame(&args[1..]);\n    38→        }\n    39→        \"git-path\" => {\n    40→            let config = config::Config::get();\n    41→            println!(\"{}\", config.git_cmd());\n    42→            std::process::exit(0);",
          "timestamp": "2025-10-13T21:02:15.496Z"
        }
      ],
      "total_additions": 364,
      "total_deletions": 0,
      "accepted_lines": 361,
      "overriden_lines": 3
    }
  }
}
