---
title: Performance FAQs
description: Git AI's performance characteristics and impact on git operations. Learn about overhead, scaling, and benchmarks for enterprise deployments.
keywords: git ai performance, git proxy overhead, git performance, enterprise scaling, benchmarks, git notes performance
---

Git AI is designed to have minimal impact on the speed of git operations when running in proxy mode. The system is built in Rust for low overhead, fast execution, and minimal memory usage.

## Testing Performance Yourself

You can measure Git AI's overhead on any command using the debug performance flag:

```bash
GIT_AI_DEBUG_PERFORMANCE=1 git-ai <command>
```

This will show you the exact overhead Git AI adds to each operation.

## Proxy Mode Overhead

When running in proxy mode, Git AI adds approximately **10-20ms of overhead** per git command. This overhead primarily comes from:
- Starting the Git AI process
- Parsing and routing git arguments to the underlying git binary
- Running pre/post-command hooks (when applicable)

Because Git AI is written in Rust, the overhead is minimal:
- **Low memory footprint** - Small binary size and efficient memory usage
- **Fast startup** - Quick process initialization
- **No background processes** - No daemons or long-running services

## Scalability

### How does Git AI scale with repository size?

Git AI operations scale with the **size of changes (diffs)**, not the size of the repository. This means performance remains consistent whether you're working in a small project or a massive monorepo.

**Checkpoint operations** (tracking AI vs human changes):
- Scale with the number of files changed
- Independent of total repository size
- Typically complete in milliseconds

**Commit operations** (generating authorship logs):
- Scale with the size of the commit diff
- The slowest operation is generating the authorship log on post-commit
- Typical range: **20-300ms** depending on commit size
- Most commits complete in under 100ms

### Example Timing Breakdown

For a typical commit with moderate changes:
- Proxy overhead: 10-20ms
- Pre-commit checkpoint: 5-15ms  
- Git commit execution: (varies by repo)
- Post-commit authorship log generation: 20-100ms
- **Total Git AI overhead: ~35-135ms**

## Git Notes Performance

Git AI stores authorship information using git notes, which sync alongside your commits. Notes have excellent performance characteristics even in large repositories.

### Sync Performance

Git note merges are fast and scale linearly with the number of **new notes**, not total notes in the repository:

| Total Notes | New Notes | Sync Time |
|------------|-----------|-----------|
| 1,000      | 10        | 0.007s    |
| 1,000      | 1,000     | 0.010s    |
| 10,000     | 10        | 0.007s    |
| 10,000     | 1,000     | 0.010s    |
| 50,000     | 10        | 0.008s    |
| 50,000     | 1,000     | 0.010s    |
| 100,000    | 10        | 0.009s    |
| 100,000    | 1,000     | 0.011s    |

As shown in the benchmarks above, sync time remains under 15ms even with 100,000 existing notes.

### Storage Considerations

**Repository size impact:**
- Notes are stored in git's object database
- Compressed and deduplicated like other git objects

**Ref limits:**
- Notes are stored in a commit tree structure, not as individual refs
- No practical limit on the number of notes
- Won't hit git's ref limits even in very large repositories

## Performance Best Practices

### For Individual Developers

1. **Use the wrapper method** - The git wrapper approach has better performance than hook-based methods
2. **Profile when needed** - Use `GIT_AI_PROFILE=1` to diagnose any performance issues
3. **Keep agents updated** - Newer versions of coding agents have optimized Git AI integration

### For Enterprise Deployments

1. **Monitor initial rollout** - Measure performance during pilot deployments
2. **Configure strategically** - Use repository allowlists to control where Git AI runs (see [Enterprise Configuration](/enterprise-configuration))
3. **Sync notes efficiently** - Notes sync automatically after push/fetch with minimal overhead
4. **No special infrastructure needed** - Git AI requires no servers, databases, or background services

## Common Performance Questions

### Does Git AI slow down git operations noticeably?

For most operations, no. The 10-20ms proxy overhead is imperceptible. The largest impact is during commits (20-300ms for authorship log generation), which is still fast enough to feel instant for typical workflows.

### Will Git AI impact CI/CD pipelines?

Git AI adds minimal overhead to git operations in CI/CD. The wrapper automatically detects when it's running in non-interactive environments and optimizes accordingly. Notes sync with your normal push/fetch operations.

### How much disk space do authorship logs use?

Authorship logs are very compact. For a typical repository with thousands of commits, authorship notes add less than 1% to the total repository size. Git's compression and deduplication keeps the overhead minimal.

### Can Git AI handle large monorepos?

Yes. Because Git AI scales with diff size rather than repository size, it works well even in massive monorepos. Operations remain fast regardless of how many files exist in the repository.

## Getting Help

If you experience performance issues with Git AI:

1. Use `GIT_AI_PROFILE=1` to measure actual overhead
2. Check the [reference documentation](/reference) for optimization options
3. [Schedule a call with the maintainers](https://calendly.com/acunniffe/meeting-with-git-ai-authors) for enterprise support

